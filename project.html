<doctype html>
    <html>
    <head>
    <title>Final Project</title>
    <script type="text/javascript" id="includedscript" src="proj.js"></script>
    <script type="text/javascript" src="gravity.js"></script>
    <script type="text/javascript" src="obj.js"></script>
    <script type="text/javascript" src="pool-table.js"></script>
    <script type="text/javascript" src="initial_situation.js"></script>
     
    <script type="text/javascript">
    document.addEventListener("keydown", keyDownTextField, false);
    function keyDownTextField(e) {
        var keyCode = e.keyCode;
        if(keyCode==115) {	// F4
            document.getElementById('includedscript').remove();
            var head = document.getElementsByTagName('head')[0];
            var script = document.createElement('script');
            script.src= 'proj.js';
            script.id = 'includedscript';
            script.onload = function() {
                primaryRT.init();
                secondaryRT.init();
                DrawScene();
            }
            head.appendChild(script);
            console.log('New script loaded.');
        }
        /*const moveSpeed = 0.1;
        const rotSpeed = 0.1;
        switch (event.key) {
            case 'ArrowUp': // Rotation on X
                viewRotX -= rotSpeed;
                break;
            case 'ArrowDown': // Rotation on X
                viewRotX += rotSpeed;
                break;
            case 'ArrowLeft': // Rotation on Y
                viewRotY -= rotSpeed;
                break;
            case 'ArrowRight': // Rotation on Y
                viewRotY += rotSpeed;
                break;
            case 'w': // forward
                viewPosX += moveSpeed * Math.sin(viewRotY);
                transZ -= moveSpeed * Math.cos(viewRotY);
                break;
            case 's': // back
                viewPosX -= moveSpeed * Math.sin(viewRotY);
                transZ += moveSpeed * Math.cos(viewRotY);
                break;
            case 'a': // left
                viewPosX -= moveSpeed * Math.cos(viewRotY);
                transZ -= moveSpeed * Math.sin(viewRotY);
                break;
            case 'd': // right
                viewPosX += moveSpeed * Math.cos(viewRotY);
                transZ += moveSpeed * Math.sin(viewRotY);
                break;
            case 'q': // up
                viewPosY += moveSpeed;
                break;
            case 'e': // down
                viewPosY -= moveSpeed;
                break;
        }*/
    }
    </script>
    
    <script id="sphereVS" type="x-shader/x-vertex">
    attribute vec3 p;
    uniform mat4  mvp;
    uniform vec3  center;
    uniform float radius;
    varying vec3 pos;
    varying vec3 normal;
    void main()
    {
        pos = p*radius + center;
        gl_Position = mvp * vec4(pos,1);
        normal = p;
    }
    </script>
    
    <script id="sphereFS" type="x-shader/x-fragment">
    precision mediump float;
    struct Material {
        vec3  k_d;	// diffuse coefficient
        vec3  k_s;	// specular coefficient
        float n;	// specular exponent
    };
    struct Light {
        vec3 position;
        vec3 intensity;
    };
    uniform samplerCube envMap;
    uniform Light    light;
    uniform vec3     campos;
    uniform Material mtl;
    varying vec3     pos;
    varying vec3     normal;
    void main()
    {
        vec3 nrm = normalize(normal);
        vec3 view = normalize( campos - pos );
        vec3 color = vec3(0,0,0);
        vec3 L = normalize( light.position - pos );
        float c = dot( nrm, L );
        if ( c > 0.0 ) {
            vec3 clr = c * mtl.k_d;
            vec3 h = normalize( L + view );
            float s = dot( nrm, h );
            if ( s > 0.0 ) {
                clr += mtl.k_s * pow( s, mtl.n );
            }
            color += clr * light.intensity;
        }
        if ( mtl.k_s.r + mtl.k_s.g + mtl.k_s.b > 0.0 ) {
            vec3 dir = reflect( -view, nrm );
            if(dir.z<-0.5) color += mtl.k_s * vec3(165/255, 42/255, 42/255);
            else color += mtl.k_s * textureCube( envMap, dir.xzy ).rgb;
        }
        gl_FragColor = vec4(color,1);
    }
    </script>
    
    <script id="raytraceVS" type="x-shader/x-vertex">
    attribute vec3 p;
    uniform mat4 proj;
    uniform mat4 c2w;
    varying vec3 ray_pos;
    varying vec3 ray_dir;
    void main()
    {
        gl_Position = proj * vec4(p,1);
        vec4 rp = c2w * vec4(0,0,0,1);
        ray_pos = rp.xyz;
        vec4 rd = c2w * vec4(p,1);
        ray_dir = rd.xyz - ray_pos;
    }
    </script>
    
    <script id="envFS" type="x-shader/x-fragment">
    precision mediump float;
    varying vec3 ray_dir;
    uniform samplerCube envMap;
    void main()
    {
        gl_FragColor = textureCube( envMap, ray_dir.xzy );
    }
    </script>
    
    <script type="text/javascript">

    var gravity;
    var mass;
    var damping;
    var stiffness;
    var springs;
    var velocities;
    var list_of_centers;
    var restitution;

    function TriSphere(subdiv)
    {
        var faces = [];
        var verts = [];
        verts.push(0,0, 1);
        verts.push(0,0,-1);
        var vpt = 0;
        var vpb = 1;
        var vi = 2;
        for ( var i=1; i<subdiv; ++i ) {
            var a = Math.PI * i / (2*subdiv);
            var z = Math.cos(a);
            var r = Math.sin(a);
            a = 0;
            var da = Math.PI / (2*i);
            var v0t = vpt;
            var v0b = vpb;
            var v1t = vi++;
            var v1b = vi++;
            verts.push(r,0, z);
            verts.push(r,0,-z);
            for ( var s=0; s<4; ++s ) {
                for ( var j=1; j<i; ++j ) {
                    a += da;
                    var x = Math.cos(a)*r;
                    var y = Math.sin(a)*r;
                    verts.push( x, y,  z );
                    verts.push( x, y, -z );
                    faces.push( v0t, vi-2, vi );
                    faces.push( v0t, vi, v0t+2 );
                    faces.push( v0b, vi-1, vi+1 );
                    faces.push( v0b, vi+1, v0b+2 );
                    v0t+=2;
                    v0b+=2;
                    vi+=2;
                }
                if ( s < 3 ) {
                    a += da;
                    var x = Math.cos(a)*r;
                    var y = Math.sin(a)*r;
                    verts.push( x, y,  z );
                    verts.push( x, y, -z );
                    faces.push( v0t, vi-2, vi );
                    faces.push( v0b, vi-1, vi+1 );
                    vi+=2;
                }
            }
            if ( i > 1 ) {
                faces[ faces.length-7 ] = vpt;
                faces[ faces.length-1 ] = vpb;
            }
            faces.push( vpt, vi-2, v1t );
            faces.push( vpb, vi-1, v1b );
            vpt = v1t;
            vpb = v1b;
        }
        var a = 0;
        var da = Math.PI / (2*subdiv);
        verts.push(1,0,0);
        var v0t = vpt;
        var v0b = vpb;
        var v1 = vi++;
        for ( var s=0; s<4; ++s ) {
            for ( var j=1; j<subdiv; ++j ) {
                a += da;
                var x = Math.cos(a);
                var y = Math.sin(a);
                verts.push( x, y, 0 );
                faces.push( v0t, vi-1, vi );
                faces.push( v0t, vi, v0t+2 );
                faces.push( v0b, vi-1, vi );
                faces.push( v0b, vi, v0b+2 );
                v0t+=2;
                v0b+=2;
                vi++;
            }
            if ( s < 3 ) {
                a += da;
                var x = Math.cos(a);
                var y = Math.sin(a);
                verts.push( x, y, 0 );
                faces.push( v0t, vi-1, vi );
                faces.push( v0b, vi-1, vi );
                vi++;
            }
        }
        if ( subdiv > 1 ) {
            faces[ faces.length-7 ] = vpt;
            faces[ faces.length-1 ] = vpb;
        }
        faces.push( vpt, vi-1, v1 );
        faces.push( vpb, vi-1, v1 );
        return { pos:verts, elems:faces };
    }
    
    var triSphere = {
        init()
        {
            var b = TriSphere(20);
            this.pbuf = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, this.pbuf);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(b.pos), gl.STATIC_DRAW);
            this.ebuf = gl.createBuffer();
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.ebuf);
            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(b.elems), gl.STATIC_DRAW);
            this.count = b.elems.length;
        },
        draw( vp )
        {
            gl.bindBuffer( gl.ARRAY_BUFFER, this.pbuf );
            gl.vertexAttribPointer( vp, 3, gl.FLOAT, false, 0, 0 );
            gl.enableVertexAttribArray( vp );
            gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, this.ebuf );
            gl.drawElements( gl.TRIANGLES, this.count, gl.UNSIGNED_SHORT, 0 );
        }
    };
    
    class SphereProg
    {
        init()
        {
            this.mvp     = gl.getUniformLocation( this.prog, 'mvp' );
            this.campos  = gl.getUniformLocation( this.prog, 'campos' );
            this.center  = gl.getUniformLocation( this.prog, 'center' );
            this.radius  = gl.getUniformLocation( this.prog, 'radius' );
            this.mtl_k_d = gl.getUniformLocation( this.prog, 'mtl.k_d' );
            this.mtl_k_s = gl.getUniformLocation( this.prog, 'mtl.k_s' );
            this.mtl_n   = gl.getUniformLocation( this.prog, 'mtl.n' );
            this.vp      = gl.getAttribLocation ( this.prog, 'p' );
        }
        setTrans( mvp, campos )
        {
            gl.useProgram( this.prog );
            gl.uniformMatrix4fv( this.mvp, false, mvp );
            gl.uniform3fv( this.campos, campos );
        }
        setLight( pos, intens )
        {
            gl.useProgram( this.prog );
            gl.uniform3fv( gl.getUniformLocation( this.prog, 'light.position'  ), pos    );
            gl.uniform3fv( gl.getUniformLocation( this.prog, 'light.intensity' ), intens );
        }
        draw( sphere )
        {
            gl.useProgram( this.prog );
            gl.uniform3fv( this.center,  sphere.center  );
            gl.uniform1f ( this.radius,  sphere.radius  );
            gl.uniform3fv( this.mtl_k_d, sphere.mtl.k_d );
            gl.uniform3fv( this.mtl_k_s, sphere.mtl.k_s );
            gl.uniform1f ( this.mtl_n,   sphere.mtl.n   );
            triSphere.draw( this.vp );
        }
    };
    
    class SphereDrawer extends SphereProg
    {
        constructor()
        {
            super();
            this.prog = InitShaderProgramFromScripts( 'sphereVS', 'sphereFS' );
            this.init();
        }
    };
    
    const transZmin = 1.001;
    const transZmax = 10;
    const maxBounceLimit = 16;
    
    var sphereDrawer;
    var canvas, gl;
    var perspectiveMatrix;	// perspective projection matrix
    var matrixMVP;
    var environmentTexture;
    var viewRotX=0, viewRotZ=0, transZ=3;
    /*var viewPosX = 0;
    var viewPosY = 0;
    var transZ = 3;
    var viewRotX = 0;
    var viewRotY = 0;
    var viewRotZ = 0;*/
    var sphereCount = 15;
    var primaryRT, secondaryRT;
    var animationId;
    var animationRunning=false;
    var dt;
    
    var spheres = fixed_spheres.slice();
    
    const raytraceFS_header = `
        precision highp float;
        precision highp int;
    `;
    
    const raytraceFS_primary = `
        varying vec3 ray_pos;
        varying vec3 ray_dir;
    
        void main()
        {
            Ray primary_ray;
            primary_ray.pos = ray_pos;
            primary_ray.dir = ray_dir;
            gl_FragColor = RayTracer( primary_ray );
        }
    `;
    
    const raytraceFS_secondary = `
        uniform Material mtl;
        uniform vec3     campos;
        varying vec3     pos;
        varying vec3     normal;
        void main()
        {
            vec3 nrm = normalize( normal );
            vec3 view = normalize( campos - pos );
            vec3 color = Shade( mtl, pos, nrm, view );
            if ( mtl.k_s.r > 0.0 || mtl.k_s.g > 0.0 || mtl.k_s.b > 0.0 ) 
            {
                Ray ray;
                ray.pos = pos;
                ray.dir = reflect( -view, nrm );
                vec4 reflection = RayTracer( ray );
                color += mtl.k_s * reflection.rgb;
            }
            gl_FragColor = vec4( color, 1 );
        }
    `;
    
    class RayTracer
    {
        constructor()
        {
            this.bounceLimit = 5;
        }
        initProg( vs, fs )
        {
            if ( this.prog ) gl.deleteProgram( this.prog );
    
            const raytraceFS_head = raytraceFS_header + `
                #define NUM_SPHERES ` + spheres.length + `
                #define NUM_LIGHTS  ` + lights.length + `
                #define MAX_BOUNCES ` + maxBounceLimit + `
            `;
            this.prog = InitShaderProgram( vs, raytraceFS_head+raytraceFS+fs );
            if ( ! this.prog ) return;
            
            function setMaterial( prog, v, mtl )
            {
                gl.uniform3fv( gl.getUniformLocation( prog, v+'.k_d' ), mtl.k_d );
                gl.uniform3fv( gl.getUniformLocation( prog, v+'.k_s' ), mtl.k_s );
                gl.uniform1f ( gl.getUniformLocation( prog, v+'.n'   ), mtl.n   );
            }
            
            gl.useProgram( this.prog );
            gl.uniform1i( gl.getUniformLocation( this.prog, 'bounceLimit' ), this.bounceLimit );
            for ( var i=0; i<spheres.length; ++i ) {
                gl.uniform3fv( gl.getUniformLocation( this.prog, 'spheres['+i+'].center' ), spheres[i].center );
                gl.uniform1f ( gl.getUniformLocation( this.prog, 'spheres['+i+'].radius' ), spheres[i].radius );
                setMaterial( this.prog, 'spheres['+i+'].mtl', spheres[i].mtl );
            }
            for ( var i=0; i<lights.length; ++i ) {
                gl.uniform3fv( gl.getUniformLocation( this.prog, 'lights['+i+'].position'  ), lights[i].position  );
                gl.uniform3fv( gl.getUniformLocation( this.prog, 'lights['+i+'].intensity' ), lights[i].intensity );
            }
            this.updateProj();
        }
        updateProj()
        {
            if ( ! this.prog ) return;
            gl.useProgram( this.prog );
            var proj = gl.getUniformLocation( this.prog, 'proj' );
            gl.uniformMatrix4fv( proj, false, perspectiveMatrix );
        }
        setBounceLimit( bounceLimit )
        {
            this.bounceLimit = bounceLimit;
            if ( ! this.prog ) return;
            gl.useProgram( this.prog );
            gl.uniform1i( gl.getUniformLocation( this.prog, 'bounceLimit' ), this.bounceLimit );
        }

        updateCenters() {
            var centersArray = new Float32Array(list_of_centers.length * 3);
            for (var i = 0; i < list_of_centers.length; i++) {
                spheres[i].center = [list_of_centers[i].x, list_of_centers[i].y, list_of_centers[i].z];
                gl.uniform3fv( gl.getUniformLocation( this.prog, 'spheres['+i+'].center' ), spheres[i].center );
                centersArray[i * 3] = list_of_centers[i].x;
                centersArray[i * 3 + 1] = list_of_centers[i].y;
                centersArray[i * 3 + 2] = list_of_centers[i].z;
            }
            gl.bindBuffer(gl.ARRAY_BUFFER, this.pbuf);
            gl.bufferSubData(gl.ARRAY_BUFFER, 0, centersArray);

            // Re-bind the buffer and attribute pointer to ensure they are set for the next draw
            this.center  = gl.getUniformLocation( this.prog, 'center' );
            gl.enableVertexAttribArray(this.center);
            gl.vertexAttribPointer(this.center, 3, gl.FLOAT, false, 0, 0);
        }
    };
    
    class PrimaryRayTracer extends RayTracer
    {
        init()
        {
            this.initProg( document.getElementById('raytraceVS').text, raytraceFS_primary );
        }
        draw( trans )
        {
            if ( ! this.prog ) return;
            screenQuad.draw( this.prog, trans );
        }
    }
    
    class SecondaryRayTracer extends RayTracer
    {
        constructor()
        {
            super();
            this.sphere = new SphereProg;
        }
        init()
        {
            this.initProg( document.getElementById('sphereVS').text, raytraceFS_secondary );
            if ( ! this.prog ) return;
            this.sphere.prog = this.prog;
            this.sphere.init();
        }
        draw( mvp, trans )
        {
            if ( ! this.prog ) return;
            background.draw( trans );
            this.sphere.setTrans( mvp, [ trans.camToWorld[12], trans.camToWorld[13], trans.camToWorld[14] ] );
            spheres.forEach( s => this.sphere.draw(s) );
        }
    }
    
    var screenQuad = {
        init( fov, z )
        {
            if ( ! this.vbuf ) this.vbuf = gl.createBuffer();
            const r = canvas.width / canvas.height;
            const ff = Math.PI * fov / 180;
            const tant_2 = Math.tan( ff/2 );
            const y = z * tant_2;
            const x = y * r;
            const rtp = [
                -x, -y, -z,
                 x, -y, -z,
                 x,  y, -z,
                -x, -y, -z,
                 x,  y, -z,
                -x,  y, -z,
            ];
            gl.bindBuffer(gl.ARRAY_BUFFER, this.vbuf);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(rtp), gl.STATIC_DRAW);
        },
        draw( prog, trans )
        {
            gl.useProgram( prog );
            gl.uniformMatrix4fv( gl.getUniformLocation( prog, 'c2w' ), false, trans.camToWorld );
            gl.bindBuffer( gl.ARRAY_BUFFER, this.vbuf );
            var p = gl.getAttribLocation ( prog, 'p' );
            gl.vertexAttribPointer( p, 3, gl.FLOAT, false, 0, 0 );
            gl.enableVertexAttribArray( p );
            gl.drawArrays( gl.TRIANGLES, 0, 6 );
        }
    };
    
    var background = {
        init()
        {
            this.prog = InitShaderProgramFromScripts( 'raytraceVS', 'envFS' );
        },
        updateProj()
        {
            gl.useProgram( this.prog );
            gl.uniformMatrix4fv( gl.getUniformLocation( this.prog, 'proj' ), false, perspectiveMatrix );
        },
        draw( trans )
        {
            gl.depthMask( false );
            screenQuad.draw( this.prog, trans );
            gl.depthMask( true );
        }
    };
    
    function InitScene()
    {
        spheres = fixed_spheres.slice();
        primaryRT.init();
        secondaryRT.init();
    }
    
    function InitEnvironmentMap()
    {
        environmentTexture = gl.createTexture();
        gl.bindTexture( gl.TEXTURE_CUBE_MAP, environmentTexture );
        
        const url = 'https://webglfundamentals.org/webgl/resources/images/computer-history-museum/';
        const files = [
          'pos-x.jpg',
          'neg-x.jpg',
          'pos-y.jpg',
          'neg-y.jpg',
          'pos-z.jpg',
          'neg-z.jpg',
        ];
        const faces = [
            gl.TEXTURE_CUBE_MAP_POSITIVE_X,
            gl.TEXTURE_CUBE_MAP_NEGATIVE_X,
            gl.TEXTURE_CUBE_MAP_POSITIVE_Y,
            gl.TEXTURE_CUBE_MAP_NEGATIVE_Y,
            gl.TEXTURE_CUBE_MAP_POSITIVE_Z,
            gl.TEXTURE_CUBE_MAP_NEGATIVE_Z,
        ];
    
        var loaded = 0;
        for ( var i=0; i<6; ++i ) {
            gl.texImage2D( faces[i], 0, gl.RGBA, 128, 128, 0, gl.RGBA, gl.UNSIGNED_BYTE, null );
            const img = new Image();
            img.crossOrigin = "anonymous";
            img.face = faces[i];
            img.onload = function() {
                gl.bindTexture( gl.TEXTURE_CUBE_MAP, environmentTexture );
                gl.texImage2D( this.face, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, this );
                loaded++;
                if ( loaded == 6 ) {
                    gl.generateMipmap(gl.TEXTURE_CUBE_MAP);
                    DrawScene();
                }
            };
            img.src = url + files[i];
        }
        gl.texParameteri( gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_LINEAR );
    }

    function LoadObjUpper( param )
    {
        if ( param.files && param.files[0] ) {
            var reader = new FileReader();
            reader.onload = function(e) {
                var mesh = new ObjMesh;
                mesh.parse( e.target.result );
                var box = mesh.getBoundingBox();
                var shift = [
                    -(box.min[0]+box.max[0])/2,
                    -(box.min[1]+box.max[1])/2,
                    -(box.min[2]+box.max[2])/2
                ];
                var size = [
                    (box.max[0]-box.min[0])/2,
                    (box.max[1]-box.min[1])/2,
                    (box.max[2]-box.min[2])/2
                ];
                var maxSize = Math.max( size[0], size[1], size[2] );
                var scale = 1/maxSize;
                mesh.shiftAndScale( shift, scale );
                var buffers = mesh.getVertexBuffers();
                for(var i=0;i<buffers.positionBuffer.length;i++){
                    buffers.positionBuffer[i]*=6;
                    if(i%3==1){
                        buffers.positionBuffer[i]-=0.3;
                        //console.log(buffers.positionBuffer[i]);
                    }
                }
                meshDrawerUpper.setMesh( buffers.positionBuffer, buffers.texCoordBuffer, buffers.normalBuffer );
                meshDrawerUpper.swapYZ(true);
                var img = new Image();
                img.src = 'pool-table/wood_wallnut.png';
                img.onload = function() {
                    meshDrawerUpper.setTexture( img );
                    //DrawScene();
                }
            }
            reader.readAsText( param.files[0] );
        }
    }

    function LoadObjLower( param )
    {
        if ( param.files && param.files[0] ) {
            var reader = new FileReader();
            reader.onload = function(e) {
                var mesh = new ObjMesh;
                mesh.parse( e.target.result );
                var box = mesh.getBoundingBox();
                var shift = [
                    -(box.min[0]+box.max[0])/2,
                    -(box.min[1]+box.max[1])/2,
                    -(box.min[2]+box.max[2])/2
                ];
                var size = [
                    (box.max[0]-box.min[0])/2,
                    (box.max[1]-box.min[1])/2,
                    (box.max[2]-box.min[2])/2
                ];
                var maxSize = Math.max( size[0], size[1], size[2] );
                var scale = 1/maxSize;
                mesh.shiftAndScale( shift, scale );
                var buffers = mesh.getVertexBuffers();
                for(var i=0;i<buffers.positionBuffer.length;i++){
                    buffers.positionBuffer[i]*=6;
                    if(i%3==1){
                        buffers.positionBuffer[i]-=1.8;
                        //console.log(buffers.positionBuffer[i]);
                    }
                }
                meshDrawerLower.setMesh( buffers.positionBuffer, buffers.texCoordBuffer, buffers.normalBuffer );
                meshDrawerLower.swapYZ(true);
                var img = new Image();
                img.src = 'pool-table/wood_wallnut.png';
                img.onload = function() {
                    meshDrawerLower.setTexture( img );
                    //DrawScene();
                }
            }
            reader.readAsText( param.files[0] );
        }
    }
    
    // Called once to initialize
    function InitWebGL()
    {
        // Initialize the WebGL canvas
        canvas = document.getElementById("canvas");
        canvas.oncontextmenu = function() {return false;};
        gl = canvas.getContext("webgl", {antialias: false, depth: true});	// Initialize the GL context
        if (!gl) {
            alert("Unable to initialize WebGL. Your browser or machine may not support it.");
            return;
        }
        
        // Initialize settings
        gl.clearColor(0,0,0,0);
        gl.enable(gl.DEPTH_TEST);
        
        InitEnvironmentMap();
    
        triSphere.init();
        background.init();
        
        primaryRT   = new PrimaryRayTracer;
        secondaryRT = new SecondaryRayTracer;

        sphereDrawer = new SphereDrawer;
        sphereDrawer.setLight( lights[0].position, lights[0].intensity );
        UpdateCanvasSize();

        let fileContent;
	    meshDrawerUpper = new MeshDrawer();
        meshDrawerLower = new MeshDrawer();

        //LoadObj();

        /*window.onload = function() {
            // Seleziona l'input di tipo file e imposta il percorso del file che desideri caricare
            var input = document.getElementById('obj');
            
            // Imposta il percorso del file che desideri caricare
            var filePath = 'pool-table/pool-table-no-balls.obj';
            
            // Crea un nuovo oggetto File utilizzando il percorso del file
            var file = new File([],'file.obj',{type:'text/plain'});
            
            // Crea un nuovo oggetto FileList contenente il tuo file
            var fileList = new DataTransfer();
            fileList.items.add(file);
            
            // Assegna il FileList al campo di input
            input.files = fileList.files;
            
            // Simula il cambiamento del campo file una volta che la pagina è stata completamente caricata
            input.dispatchEvent(new Event('change'));
        };*/

        InitScene();
        
    }
    
    // Called every time the window size is changed.
    function UpdateCanvasSize()
    {
        canvas.style.width  = "100%";
        canvas.style.height = "100%";
        const pixelRatio = window.devicePixelRatio || 1;
        canvas.width  = pixelRatio * canvas.clientWidth;
        canvas.height = pixelRatio * canvas.clientHeight;
        const width  = (canvas.width  / pixelRatio);
        const height = (canvas.height / pixelRatio);
        canvas.style.width  = width  + 'px';
        canvas.style.height = height + 'px';
        gl.viewport( 0, 0, canvas.width, canvas.height );
        UpdateProjectionMatrix();
    }
    
    function UpdateProjectionMatrix()
    {
        const fov = 100;
        var r = canvas.width / canvas.height;
        var n = 0.1;
        const min_n = 0.001;
        if ( n < min_n ) n = min_n;
        var f = transZmax*100;
        var ff = Math.PI * fov / 180;
        var tant_2 = Math.tan( ff/2 );
        var s = 1 / tant_2;
        perspectiveMatrix = [
            s/r, 0, 0, 0,
            0, s, 0, 0,
            0, 0, -(n+f)/(f-n), -1,
            0, 0, -2*n*f/(f-n), 0
        ];
        
        screenQuad.init(fov,(n+f)/2);
        background.updateProj();
        primaryRT.updateProj();
        secondaryRT.updateProj();
    }
    
    function GetTrans()
    {
        function dot(a,b) { return a[0]*b[0] + a[1]*b[1] + a[2]*b[2]; }
        /*function normalize(a) {
            var len = Math.sqrt(dot(a, a));
            return [a[0]/len, a[1]/len, a[2]/len];
        }
        function cross(a, b) {
            return [
                a[1]*b[2] - a[2]*b[1],
                a[2]*b[0] - a[0]*b[2],
                a[0]*b[1] - a[1]*b[0]
            ];
        }

        var cz = Math.cos(viewRotZ);
        var sz = Math.sin(viewRotZ);
        var cx = Math.cos(viewRotX);
        var sx = Math.sin(viewRotX);
        var cy = Math.cos(viewRotY);
        var sy = Math.sin(viewRotY);

        var forward = normalize([cy*sz, -cy*cz, sx]);
        var right = normalize(cross(forward, [0, 1, 0]));
        var up = cross(right, forward);

        var c = [
            viewPosX,
            viewPosY,
            transZ
        ];

        var worldToCam = [
            right[0], up[0], -forward[0], 0,
            right[1], up[1], -forward[1], 0,
            right[2], up[2], -forward[2], 0,
            -dot(right, c), -dot(up, c), dot(forward, c), 1,
        ];

        var camToWorld = [
            right[0], right[1], right[2], 0,
            up[0], up[1], up[2], 0,
            -forward[0], -forward[1], -forward[2], 0,
            c[0], c[1], c[2], 1
        ];*/

        var cz = Math.cos( viewRotZ );
        var sz = Math.sin( viewRotZ );
        var cx = Math.cos( viewRotX );
        var sx = Math.sin( viewRotX );
    
        var z = [ cx*sz, -cx*cz, sx ];
        var c = [ z[0]*transZ, z[1]*transZ, z[2]*transZ ];	
        var xlen = Math.sqrt( z[0]*z[0] + z[1]*z[1] );
        var x = [ -z[1]/xlen, z[0]/xlen, 0 ];
        var y = [ z[1]*x[2] - z[2]*x[1], z[2]*x[0] - z[0]*x[2], z[0]*x[1] - z[1]*x[0] ];
        
        var worldToCam = [
            x[0], y[0], z[0], 0,
            x[1], y[1], z[1], 0,
            x[2], y[2], z[2], 0,
            -dot(x,c), -dot(y,c), -dot(z,c), 1,
        ];
        var camToWorld = [
            x[0], x[1], x[2], 0,
            y[0], y[1], y[2], 0,
            z[0], z[1], z[2], 0,
            c[0], c[1], c[2], 1
        ];
        return { camToWorld: camToWorld, worldToCam: worldToCam };
    }

    // This is the main function that handled WebGL drawing
    function DrawScene()
    {
        gl.flush();
        
        var trans = GetTrans();
        var mvp = MatrixMult( perspectiveMatrix, trans.worldToCam );
    
        // Clear the screen and the depth buffer.
        gl.clear( gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT );
    
        // Rasterization
        if ( document.getElementById('raster').checked ) {
            var trans=GetTrans();
            matrixMVP=MatrixMult( perspectiveMatrix, trans.worldToCam );
            var mv=trans.worldToCam;
            var nrmTrans = [ mv[0],mv[1],mv[2], mv[4],mv[5],mv[6], mv[8],mv[9],mv[10] ];
            var campos = [mv[12],mv[13],mv[14]]
            meshDrawerUpper.draw(matrixMVP, mv, nrmTrans, campos);
            meshDrawerLower.draw(matrixMVP, mv, nrmTrans, campos);
            //console.log(meshDrawer);
            
            background.draw( trans );
            sphereDrawer.setTrans( mvp, [ trans.camToWorld[12], trans.camToWorld[13], trans.camToWorld[14] ] );
            spheres.forEach( s => sphereDrawer.draw(s) );
        }
        
        // Ray Tracing
        if ( document.getElementById('raytrace').checked ) {
            primaryRT.draw( trans );
        }
        
        // Rasterization + Ray Tracing
        if ( document.getElementById('secondary').checked ) {
            secondaryRT.draw( mvp, trans );
        }
    }
    
    // This is a helper function for compiling the given vertex and fragment shader script ids into a program.
    function InitShaderProgramFromScripts( vs, fs )
    {
        return InitShaderProgram( document.getElementById(vs).text, document.getElementById(fs).text );	
    }
    
    // This is a helper function for compiling the given vertex and fragment shader source code into a program.
    function InitShaderProgram( vsSource, fsSource )
    {
        const vs = CompileShader( gl.VERTEX_SHADER,   vsSource );
        const fs = CompileShader( gl.FRAGMENT_SHADER, fsSource );
    
        if ( ! vs || ! fs ) return null;
        
        const prog = gl.createProgram();
        gl.attachShader(prog, vs);
        gl.attachShader(prog, fs);
        gl.linkProgram(prog);
    
        if (!gl.getProgramParameter(prog, gl.LINK_STATUS)) {
            alert('Unable to initialize the shader program: ' + gl.getProgramInfoLog(prog));
            return null;
        }
        return prog;
    }
    
    // This is a helper function for compiling a shader, called by InitShaderProgram().
    function CompileShader( type, source )
    {
        const shader = gl.createShader(type);
        gl.shaderSource(shader, source);
        gl.compileShader(shader);
        if (!gl.getShaderParameter( shader, gl.COMPILE_STATUS) ) {
            alert('An error occurred compiling shader:\n' + gl.getShaderInfoLog(shader));
            gl.deleteShader(shader);
            return null;
        }
        return shader;
    }
    
    // Multiplies two matrices and returns the result A*B.
    // The arguments A and B are arrays, representing column-major matrices.
    function MatrixMult( A, B )
    {
        var C = [];
        for ( var i=0; i<4; ++i ) {
            for ( var j=0; j<4; ++j ) {
                var v = 0;
                for ( var k=0; k<4; ++k ) {
                    v += A[j+4*k] * B[k+4*i];
                }
                C.push(v);
            }
        }
        return C;
    }
    
    window.onload = function() {
        InitWebGL();
        canvas.zoom = function( s ) {
            transZ *= s/canvas.height + 1;
            if ( transZ < transZmin ) transZ = transZmin;
            if ( transZ > transZmax ) transZ = transZmax;
            UpdateProjectionMatrix();
            DrawScene();
        }
        canvas.onwheel = function() { canvas.zoom(0.3*event.deltaY); }
        canvas.onmousedown = function() {
            var cx = event.clientX;
            var cy = event.clientY;
            if ( event.ctrlKey ) {
                canvas.onmousemove = function() {
                    canvas.zoom(5*(event.clientY - cy));
                    cy = event.clientY;
                }
            } else {
                canvas.onmousemove = function() {
                    viewRotZ += (cx - event.clientX)/canvas.width*5;
                    viewRotX -= (cy - event.clientY)/canvas.height*5;
                    cx = event.clientX;
                    cy = event.clientY;
                    const eps = 0.01;
                    if ( viewRotX < -0.1 ) viewRotX = -0.1;
                    if ( viewRotX > Math.PI/2 - eps ) viewRotX = Math.PI/2 - eps;
                    UpdateProjectionMatrix();
                    DrawScene();
                }
            }
        }
        canvas.onmouseup = canvas.onmouseleave = function() {
            canvas.onmousemove = null;
        }
        
        DrawScene();
    };
    
    function WindowResize()
    {
        UpdateCanvasSize();
        DrawScene();
    }
    
    function UseEnvironmentMap( param )
    {
        gl.bindTexture( gl.TEXTURE_CUBE_MAP, param.checked ? environmentTexture : null );
        DrawScene();
    }
    
    function IncBounceLimit( inc )
    {
        var b = parseInt(document.getElementById('bounces-value').innerText);
        b += inc;
        if ( b < 0 ) b = 0;
        if ( b > maxBounceLimit ) b = maxBounceLimit;
        SetBounceLimit( b );
        document.getElementById('bounces-range').value = b;
    }
    
    function SetBounceLimit( b )
    {
        document.getElementById('bounces-value').innerText = b;
        primaryRT.setBounceLimit( b );
        secondaryRT.setBounceLimit( b );
        UpdateProjectionMatrix();
        DrawScene();
    }

    function StartSimulation(){
        velocities=Array(spheres.length);
        list_of_centers = Array(spheres.length);
        radii = Array(spheres.length);
        for(var i=0;i<spheres.length;i++){
            list_of_centers[i]=ToVec3(spheres[i].center);
            radii[i]=spheres[i].radius;
            velocities[i]=new Vec3(0.0,0.0,0.0);
        }
        CreateAnimation();
    }

    function CreateAnimation(){
        if(animationId) return;
        function render() {
            gravity=new Vec3( 0, 0.0, -1*parseInt(document.getElementById("gravity-value").innerText));
            mass=parseInt(document.getElementById("mass-value").innerText);
            muS=parseInt(document.getElementById("static-friction-value").innerText)/100;
            muD=parseInt(document.getElementById("dynamic-friction-value").innerText)/100;
            restitution=parseInt(document.getElementById("restitution-value").innerText)/100;

            dt = 0.016; // Assuming a framerate of 60 FPS, dt is ~16 ms
            SimTimeStep(dt, list_of_centers, radii ,velocities, muS, muD, mass, gravity, restitution, holes);
            primaryRT.updateCenters();
            secondaryRT.updateCenters();
            DrawScene();
            animationId = requestAnimationFrame(render);
        }

        animationRunning=true;
        render();
    }

    function PauseSimulation(){
        if(!animationRunning) return;
        
        animationRunning = false;
        if (animationId) {
            cancelAnimationFrame(animationId);
            animationId = undefined;
        }
    }

    function Reset(){

        if (animationId) {
            cancelAnimationFrame(animationId);
        }

        fixed_spheres = [
            {   //b0
                center: [ 0, 0, 0 ],
                radius: 0.2,
                mtl: {
                    k_d: [ Math.random(), Math.random(), Math.random() ],
                    k_s: [ 0.8, 0.8, 0.8 ],
                    n: 100
                }
            },
            {   //b1
                center: [ 0.4, 0, 0 ],
                radius: 0.2,
                mtl: {
                    k_d: [ Math.random(), Math.random(), Math.random() ],
                    k_s: [ 0.8, 0.8, 0.8 ],
                    n: 100
                }
            },
            {   //b2
                center: [ -0.4, 0, 0 ],
                radius: 0.2,
                mtl: {
                    k_d: [ Math.random(), Math.random(), Math.random() ],
                    k_s: [ 0.8, 0.8, 0.8 ],
                    n: 100
                }
            },
            ///
            {   //b3
                center: [ -0.2, 0.35, 0 ],
                radius: 0.2,
                mtl: {
                    k_d: [ Math.random(), Math.random(), Math.random() ],
                    k_s: [ 0.8, 0.8, 0.8 ],
                    n: 100
                }
            },
            {   //b4
                center: [ 0.2, 0.35, 0 ],
                radius: 0.2,
                mtl: {
                    k_d: [ Math.random(), Math.random(), Math.random() ],
                    k_s: [ 0.8, 0.8, 0.8 ],
                    n: 100
                }
            },
            ///
            {   //b5
                center: [ 0.0, 0.7, 0 ],
                radius: 0.2,
                mtl: {
                    k_d: [ Math.random(), Math.random(), Math.random() ],
                    k_s: [ 0.8, 0.8, 0.8 ],
                    n: 100
                }
            },
            ///
            {   //b6
                center: [ 0.2, -0.35, 0 ],
                radius: 0.2,
                mtl: {
                    k_d: [ Math.random(), Math.random(), Math.random() ],
                    k_s: [ 0.8, 0.8, 0.8 ],
                    n: 100
                }
            },
            {   //b7
                center: [ -0.2, -0.35, 0 ],
                radius: 0.2,
                mtl: {
                    k_d: [ Math.random(), Math.random(), Math.random() ],
                    k_s: [ 0.8, 0.8, 0.8 ],
                    n: 100
                }
            },
            {   //b8
                center: [ -0.6, -0.35, 0 ],
                radius: 0.2,
                mtl: {
                    k_d: [ Math.random(), Math.random(), Math.random() ],
                    k_s: [ 0.8, 0.8, 0.8 ],
                    n: 100
                }
            },
            {   //b9
                center: [ 0.6, -0.35, 0 ],
                radius: 0.2,
                mtl: {
                    k_d: [ Math.random(), Math.random(), Math.random() ],
                    k_s: [ 0.8, 0.8, 0.8 ],
                    n: 100
                }
            },
            ///
            {   //b10
                center: [ 0, -0.7, 0 ],
                radius: 0.2,
                mtl: {
                    k_d: [ Math.random(), Math.random(), Math.random() ],
                    k_s: [ 0.8, 0.8, 0.8 ],
                    n: 100
                }
            },
            {   //b11
                center: [ 0.4, -0.7, 0 ],
                radius: 0.2,
                mtl: {
                    k_d: [ Math.random(), Math.random(), Math.random() ],
                    k_s: [ 0.8, 0.8, 0.8 ],
                    n: 100
                }
            },
            {   //b12
                center: [ 0.8, -0.7, 0 ],
                radius: 0.2,
                mtl: {
                    k_d: [ Math.random(), Math.random(), Math.random() ],
                    k_s: [ 0.8, 0.8, 0.8 ],
                    n: 100
                }
            },
            {   //b13
                center: [ -0.4, -0.7, 0 ],
                radius: 0.2,
                mtl: {
                    k_d: [ Math.random(), Math.random(), Math.random() ],
                    k_s: [ 0.8, 0.8, 0.8 ],
                    n: 100
                }
            },
            {   //b14
                center: [ -0.8, -0.7, 0 ],
                radius: 0.2,
                mtl: {
                    k_d: [ Math.random(), Math.random(), Math.random() ],
                    k_s: [ 0.8, 0.8, 0.8 ],
                    n: 100
                }
            },
            {   //white
                center: [ 0, 4, 0 ],
                radius: 0.2,
                mtl: {
                    k_d: [ 1.0, 1.0, 1.0 ],          
                    k_s: [ 0.2, 0.2, 0.2 ],
                    n: 100
                }
            }
        ];

        lights = [
            {
                position:  [ 0, 0, 10 ],
                intensity: [ 1, 1, 1 ]
            }
        ];

        velocities=Array(spheres.length);
        list_of_centers = Array(spheres.length);
        for(var i=0;i<spheres.length;i++){
            list_of_centers[i]=ToVec3(spheres[i].center);
            velocities[i]=new Vec3(0.0,0.0,0.0);
        }
        
        // Clear the canvas
        var canvas = document.getElementById('canvas');
        var gl = canvas.getContext('webgl');
        if (gl) {
            gl.clearColor(0.0, 0.0, 0.0, 1.0);
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
        }

        // Reinitialize scene and redraw
        iteration=undefined;
        animationId=undefined;
        animationRunning=false;
        InitScene();
        primaryRT.init();
        secondaryRT.init();
        DrawScene();
    }
    
    function IncCount( inc )
    {
        var c = parseInt(document.getElementById('count-value').innerText);
        c += inc;
        if ( c < 1 ) c = 1;
        if ( c > 100 ) c = 100;
        SetCount( c );
        document.getElementById('count-range').value = c;
        NewScene();
    }
    
    function SetCount( c )
    {
        document.getElementById('count-value').innerText = c;
        sphereCount = c;
    }
    
    function NewScene()
    {
        InitScene();
        primaryRT.init();
        secondaryRT.init();
        DrawScene();
    }
    
    function ShowControls()
    {
        var c = document.getElementById('controls');
        c.style.display = c.style.display == 'none' ? '' : 'none';
    }

    function SetShininess( param )
    {
        var exp = param.value;
        var s = Math.pow(10,exp/25);
        document.getElementById('shininess-value').innerText = s.toFixed( s < 10 ? 2 : 0 );
        meshDrawerUpper.setShininess(s);
        meshDrawerLower.setShininess(s);
        DrawScene();
    }

    function SetSpecularity(param){
        var exp = param.value;
        var s = exp/100;
        document.getElementById('specularity-value').innerText = exp;
        meshDrawerUpper.setSpecularity(s);
        meshDrawerLower.setSpecularity(s);
        DrawScene();
    }

    function changeMax(param){
        var exp = param.value;
        var elem1=document.getElementById("static-friction-value");
        elem1.innerText=exp;
        var elem2=document.getElementById("dynamic-friction-exp");
        elem2.max=exp;
        var elem3=document.getElementById("dynamic-friction-value");
        if(parseInt(elem3.innerText)>exp){
            elem3.innerText=exp;
        }
    }

    function change(param){
        var exp = param.value;
        var elem1=document.getElementById("dynamic-friction-value");
        elem1.innerText=exp;
    }

    function update(param){
        var exp = param.value;
        var elem1=document.getElementById("restitution-value");
        elem1.innerText=exp;
    }

    function updateGravity(param){
        var exp = param.value;
        var elem1=document.getElementById("gravity-value");
        elem1.innerText=exp;
    }

    function updateMass(param){
        var exp = param.value;
        var elem1=document.getElementById("mass-value");
        elem1.innerText=exp;
    }
    
    ///////////////////////////////////////////////////////////////////////////////////
    </script>
    
    <style>
    html {
        color: white;
        background-color: black;
        font-family: Arial;
        overflow: hidden;
    }
    body {
        padding: 0;
        margin: 0;
    }
    input[type=checkbox], label {
        cursor: hand;
    }
    input[type=range] {
        width: 100%;
    }
    canvas {
        display: block;
        position: absolute;
        top:  0;
        left: 0;
        width:  100%;
        height: 100%;
    }
    #canvas-div {
        position: relative;
        width: 100%;
        height: 100%;
    }
    #controls-div {
        background-color: rgba(0,0,0,0.5);
        position: absolute;
        right: 1em;
        top: 1em;
        width: 18em;
        max-height: 600px; 
        overflow-y: auto; 
        border: 1px solid #ccc; 
        padding: 10px;
    }
    #controls {
        padding: 1em;
    }
    .control {
        padding: 0.2em;
        clear: both;
    }
    .val {
        float: right;
        text-align: right;
    }
    .value {
        margin-right: 0.5em;
    }
    .btn {
        width: 100%;
    }
    #buttons {
        position: absolute;
        right: 0;
        top: 0;
    }
    #buttons input[type=button] {
        background-color: rgba(80,80,80,0.5);
        color: #aaa;
        font-size: 70%;
        outline: none;
    }
    </style>
    
    </head>
    <body onresize="WindowResize()">
    <div id="canvas-div"><canvas id="canvas"></canvas></div><div id="controls-div">
    <div id="buttons"><input type="button" value="V" onclick="ShowControls()"/></div>
    <div id="controls">
    <div class="control-group">
    <div class="control"><input id="raster" name="method" type="radio" onchange="DrawScene()" /><label for="raster"> Rasterization</label><br/></div>
    <div class="control"><input id="raytrace" name="method" type="radio" onchange="DrawScene()" checked /><label for="raytrace"> Ray Tracing</label><br/></div>
    <div class="control"><input id="secondary" name="method" type="radio" onchange="DrawScene()" /><label for="secondary"> Rasterization + Ray Tracing</label><br/></div>
    <div class="control"><hr/></div>
    <div class="control"><input id="envmap" name="envmap" type="checkbox" onchange="UseEnvironmentMap(this)" checked /><label for="envmap"> Environment Map</label></div>
    <div class="control"><span id="bounces-label">Bounce Limit:</span><span class="val"><span class="value" id="bounces-value">5</span><input type="button" value="+" onclick="IncBounceLimit(1)"><input type="button" value="&ndash;" onclick="IncBounceLimit(-1)"></span><input id="bounces-range" type="range" min="0" max="16" value="5" oninput="SetBounceLimit(this.value)"/></div>
    <div class="control"><span id="shininess-label">Shininess:</span><span id="shininess-value">1</span><input id="shininess-exp" type="range" min="0" max="100" value="1" oninput="SetShininess(this)"/></div>
    <div class="control"><span id="specularity-label">Specularity:</span><span id="specularity-value">30</span><input id="specularity-exp" type="range" min="0" max="100" value="30" oninput="SetSpecularity(this)"/></div>
    <div class="control"><span id="static-friction-label">Static Friction:</span><span id="static-friction-value">30</span><input id="static-friction-exp" type="range" min="0" max="100" value="30" oninput="changeMax(this)"/></div>
    <div class="control"><span id="dynamic-friction-label">Dynamic Friction:</span><span id="dynamic-friction-value">20</span><input id="dynamic-friction-exp" type="range" min="0" max="100" value="20" oninput="change(this)"/></div>
    <div class="control"><span id="restitution-label">Restitution:</span><span id="restitution-value">80</span><input id="restitution-exp" type="range" min="0" max="100" value="80" oninput="update(this)"/></div>
    <div class="control"><span id="gravity-label">Gravity:</span><span id="gravity-value">1</span><input id="gravity-exp" type="range" min="1" max="100" value="1" oninput="updateGravity(this)"/></div>
    <div class="control"><span id="mass-label">Mass:</span><span id="mass-value">2</span><input id="mass-exp" type="range" min="1" max="15" value="2" oninput="updateMass(this)"/></div>
    <div class="control-group">
    <div class="control">Upper OBJ model:<br/><input id="objupper" type="file" onchange="LoadObjUpper(this)" accept=".obj"/></div>
    <div class="control">Lower OBJ model:<br/><input id="objlower" type="file" onchange="LoadObjLower(this)" accept=".obj"/></div>
    <div class="control"><input type="button" value="Start Simulation" onclick="StartSimulation()"></div>
    <div class="control"><input type="button" value="Pause Simulation" onclick="PauseSimulation()"></div>
    <div class="control"><input type="button" value="Resume Simulation" onclick="CreateAnimation()"></div>
    <div class="control"><input type="button" value="Reset Simulation" onclick="Reset()"></div>
    <!--<div class="control">Texture image:<br/><input id="texture" type="file" onchange="LoadTexture(this)" accept="image/*"/></div>-->
    </div>
    </div>
    </div>
    </div>
    </div>
    </body>
    </html>